// apps/web/app/api/export-pdf/route.ts
/* Runtime note:
 * pdfkit requires Node APIs, so keep this on the Node runtime (not 'edge').
 */
export const runtime = 'nodejs';

import { NextRequest, NextResponse } from 'next/server';
import PDFDocument from 'pdfkit';
import { createClient } from '@supabase/supabase-js';
import { randomUUID } from 'crypto';

type ExportPdfPayload = {
  finalText: string;
  title?: string;
  meta?: {
    preset?: string | null;
    duration?: string | null;
  } | null;
};

function generatePdfBuffer({
  finalText,
  title,
  meta,
}: {
  finalText: string;
  title?: string;
  meta?: { preset?: string | null; duration?: string | null } | null;
}): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margin: 56, // ~20mm
        info: {
          Title: title || 'Speechwriter Export',
          Author: 'Speechwriter',
        },
      });

      const chunks: Buffer[] = [];
      doc.on('data', chunk => chunks.push(Buffer.from(chunk)));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', err => reject(err));

      // Brand header
      doc
        .fontSize(10)
        .fillColor('#6b7280')
        .text('Speechwriter — Halo MicroFactory', { align: 'right' })
        .moveDown(0.5);

      // Title
      const safeTitle =
        title?.trim() ||
        (finalText
          .split('\n')
          .find(l => l.trim().length > 0)
          ?.trim() ??
          'Export');
      doc.fontSize(20).fillColor('#111827').text(safeTitle, { align: 'left' }).moveDown(0.25);

      // Meta line
      const metaParts: string[] = [];
      const date = new Date().toLocaleString();
      metaParts.push(date);
      if (meta?.preset) metaParts.push(`Preset: ${meta.preset}`);
      if (meta?.duration) metaParts.push(`Duration: ${meta.duration}`);

      doc
        .fontSize(11)
        .fillColor('#374151')
        .text(metaParts.join('   •   '), { align: 'left' })
        .moveDown(0.75);

      // Divider
      const y = doc.y;
      doc
        .moveTo(doc.page.margins.left, y)
        .lineTo(doc.page.width - doc.page.margins.right, y)
        .lineWidth(0.5)
        .strokeColor('#e5e7eb')
        .stroke()
        .moveDown(0.75);

      // Body
      doc.fontSize(12).fillColor('#111827');

      // Wrap paragraphs
      const paragraphs = finalText.replace(/\r\n/g, '\n').split('\n');
      for (const p of paragraphs) {
        const line = p.trim();
        if (!line) {
          doc.moveDown(0.5);
          continue;
        }
        doc.text(line, { align: 'left' }).moveDown(0.2);
      }

      // Footer
      doc.moveDown(1.0);
      doc.fontSize(9).fillColor('#6b7280').text('Generated by Speechwriter', { align: 'right' });

      doc.end();
    } catch (e) {
      reject(e);
    }
  });
}

export async function POST(req: NextRequest) {
  try {
    const { finalText, title, meta }: ExportPdfPayload = await req.json();

    if (!finalText || typeof finalText !== 'string' || finalText.trim().length === 0) {
      return NextResponse.json({ error: 'Missing or empty finalText' }, { status: 400 });
    }

    const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!SUPABASE_URL || !SERVICE_KEY) {
      return NextResponse.json(
        {
          error:
            'Missing Supabase server env. Set NEXT_PUBLIC_SUPABASE_URL & SUPABASE_SERVICE_ROLE_KEY.',
        },
        { status: 500 }
      );
    }

    const pdfBuffer = await generatePdfBuffer({ finalText, title, meta });

    const supabase = createClient(SUPABASE_URL, SERVICE_KEY);
    const filename = `pdf/${randomUUID()}.pdf`;

    const { data: upload, error: uploadErr } = await supabase.storage
      .from('exports')
      .upload(filename, pdfBuffer, {
        contentType: 'application/pdf',
        upsert: false,
      });

    if (uploadErr) {
      return NextResponse.json({ error: `Upload failed: ${uploadErr.message}` }, { status: 500 });
    }

    // Public URL (bucket must be public)
    const { data: pub } = supabase.storage.from('exports').getPublicUrl(filename);
    return NextResponse.json({ url: pub.publicUrl }, { status: 200 });
  } catch (err: any) {
    return NextResponse.json({ error: err?.message ?? 'Unknown error' }, { status: 500 });
  }
}
